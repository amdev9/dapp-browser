# Loader
*Старое предложение, неактуально в текущей архитектуре - возможно использование относительно формулирование работы loader для сервисов.*

Модульная система внутри нашей основной, которая будет сама рапределять зависимости и разрешенные области действий и api доступных из компонентов.
Вдохновлено [requirejs](http://requirejs.org/docs/api.html)

Система runtime инициализации модулей позволит нам соответствовать принципу по которому все предоставляемые нами api компонентов которые мы в последующем предоставляем пользователям являются самодостаточными сущностями изолированными от общего пространства nodejs и где все права выдаются относитльно общей иерархии зависимостей при которой компоненты могут использовать только другие компоненты для работы с функционалом, и только нескольким модулям дается ограниченное разрешение на использование API nodejs.

``` js
// Компонент - изолированное замыкание контекста, которое может зарегистироватся только в Loader, только с теми компонентами в области видимости что мы ему даем
const ComponentEnv = ((OtherComponent, Environment, Loader, ...otherArgs) => {
    // Класс - приватная сущность в замыкании
    class MyComponent {
        // Констркутор приватная сущность доступная только в замыкании, без возможности создать новый экземпляр из Dapp
        private constructor(...otherArgs) { .. }
    }

    // Инстанс - сущность компонента являющаяся константой с предустановленным окружением и аргументами 
    const componentContext = new MyComponent(Environment, ...otherArgs);
    // Возвращает упакованный в loader контекст модуля
    return Loader.pack_context('MyComponent', componentContext)
})// (OtherComponent, Environment, LoaderInstanse, ...args)

// Создаем Loader с обозначенным окружением
let loader = new Loader(ENV)
// Исполняем окружение нужного компонента с доступными для него API относительно упакованного контекста
loader.register_component(ComponentEnv)
// Создаем финализированный образ с чистыми контекстами и Proxy
let GlobalContext = loader.finalize();

// Из DApp вызываем доступ к компоненту как к экземпляру сущности через прокси
const { MyComponent } = GlobalContext
```

Примерный API работы с модульной системой:
- Создается контекст загрузчика который в себе хранит пространство имен экземпляров модулей
- Регистрируются изолированные namespace с имплементациями компонентов
    - Создается изолированное замыкание в котором объявляются классы и реализации, с доступом к запрашиваемым модулям компонентов
    - В замыкании компонента объявляются экземпляры компонентов с предустановленным environment для взаимодействия
    - Экземпляр регистрируется в модульном загрузчике инстанс которого передается как аргумент в замыкании
- Вызывается метод finalize() который возвращает чистый мета-объект Proxy который управляет доступом к компонентом из DApp с предустановленным для него окружением

