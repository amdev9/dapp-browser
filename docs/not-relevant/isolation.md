# Изоляция окружений
*Устарело и неактуально, переопределить по текущей архитектруре.*

Раздел посвящен разбору безопасности и изоляции в приложении системных компонентов, и работы с безопасностью окружения изнутри и снаружи.

### Цели
- Изоляция общего окружения клиента и dapps от вмешательства снаружи
    - Изоляция файловой системы от вмешательства снаружи, и со второны dapp
    - Изоляция системных потоков, для исключения возможности считывать с них информацию
    - Изоляция сети - чтобы исключить вероятность атаки "человек посередине", и создания подделанных запросов.
- Изоляция системных компонентов клиента
    - Компоненты могут вызывать только себя, и использовать только те API что мы им разрешили
    - Модель иерархии работает по принципу сверху вниз только по уровню прав. Пример: если DApp вызывает модуль Logger с методом записи лога в Storage - то Logger разрешено использовать только модуль Storage без прямого вызова и доступа к fs модулю.
    - У модулей должен быть закрыт контекст работы с клиентским окружением, но при этом у DApp имеется возможность запуска своего именованного окружения с компонентами.

### Изоляция на уровне системы
- Windows - полная изоляция файловой системы, изолированное сетевое окружение, и доступ (требуется тщательная проверка)
- [Mac](https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AboutAppSandbox/AboutAppSandbox.html) - изоляция на уровне сети, и частично работы с файлами (нужно дополнительно исследовать)
- [Linux](https://docs.ubuntu.com/core/en/guides/intro/security) - изоляция на уровне сети, изоляция окружения и файловой системы с apparmor

### Runtime изоляция компонентов
- Изоляция области работает через специальный Loader компонент, который являет собой обособленный контекст, инициализирующийся относительно контекста конкретного DApp, и предоставляющий доступ к API через Proxy абстракцию, которая позволит проводить дополнительную валидацию операций, и исключить возможность перезаписи каких либо компонентов или их методов. Работать Loader будет по системе инициализаци компонентов в изолированном замыкании только с теми частями системы и иерархии которые мы им разрешим

``` js
// Компонент - изолированное замыкание контекста, которое может зарегистироватся только в Loader, только с теми компонентами в области видимости что мы ему даем
const ComponentEnv = ((OtherComponent, Environment, Loader, ...otherArgs) => {
    // Класс - приватная сущность в замыкании
    class MyComponent {
        // Констркутор приватная сущность доступная только в замыкании, без возможности создать новый экземпляр из Dapp
        private constructor(...otherArgs) { .. }
    }

    // Инстанс - сущность компонента являющаяся константой с предустановленным окружением и аргументами 
    const componentContext = new MyComponent(Environment, ...otherArgs);
    // Возвращает упакованный в loader контекст модуля
    return Loader.pack_context('MyComponent', componentContext)
})// (OtherComponent, Environment, LoaderInstanse, ...args)

// Создаем Loader с обозначенным окружением
let loader = new Loader(ENV)
// Исполняем окружение нужного компонента с доступными для него API относительно упакованного контекста
loader.register_component(ComponentEnv)
// Создаем финализированный образ с чистыми контекстами и Proxy
let GlobalContext = loader.finalize();

// Из DApp вызываем доступ к компоненту как к экземпляру сущности через прокси
const { MyComponent } = GlobalContext
```

Изоляция на уровне Loader позволит нам создавать изолированные итнграционные тесты относительно системы тестирования с частной предустановкой нужного нам окружения, а также позволит инициализировать контексты для пользовательских тестов и работы с DApp в development режиме в котором у них не будет доступа к системе, но при этом будут API работающие идентично тому как они бы работали в production режиме.

Новосозданный контекст упаковываем в контекст vm2 и загружаем как preload script в окружение DApp. Таким образом мы решаем пробелму окружения, безопасности, и не плодим слишком много сущностей которые будут хранится как лишние процессы ОС - потребляющие слишком много ресурсов и снижающие общую производительность. Также это решает проблему работы с бинарными кусками данных, которые изза своего размера не с смогут оптимально проходить по IPC который предназначен в первую очередь для коротких или единых сообщений - и на прикладном уровне в electron не предназначен для общения непрерывным бинарным стримом.

### Аргументы против создания излишних процессов и работы абсолютно со всеми компонентами через IPC
- Вариант использования redux-observable неактуален
    - Излишне большой рантайм не предназначенный для интеграции с redux: redux-observable предназначен для работы только с потоками сообщений, и не приспособлен к тому чтобы через себя пропускать какие бы то ни было бинарные данные, slack никогда не работал с бинарными данными, и пропускает через него только потоки сообщений от других приложений которые не имеют никакого доступа к fs.
    - redux-observable основан на реактивном фреймворке rxjs, который очень большой, и его крайне сложно готовить, и если с ним работать нужно чтобы целиком вся система была основана на observable потоках. Мы тащим за собой очень большой и плохо контролируемый runtime который потом не сможем поддерживать. Оверинженеринг.
- Каждый новый созданный процесc, это новая избыточная сущность с которой будет сложно работать и взаимодействовать, она будет избыточно нагружать систему и модель взаимодействий, поэтому применять ее ко всем компонентам api будет оверинженерингом.
- Модель с использованием изолированной сущности в которой мы изолируем свои же компоненты в рантайм модульной системе дает больше гарантий безопасности и при этом не создает лишних проблем после упаковки в VM2 - при этом давая возможность без оверхэда достичь и безопасности и производительности
- Модель взаимодействия IPC лучше оставить для работы с Activity и взаимодействием между DApp потому что она лучше работает с событиями и цельными структурами данных - что ценно для наших activity потому что для безопасности мы запрещаем им общаться бинарными данными.