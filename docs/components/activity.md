# Activity
Система взаимодействия между собой DApps по потокам сервисов сообщений.

### Цели
- Возможность DApp запрашивать разрешения на использование сервисов другого DApp
- Возможность декларировать резервацию на набор функций которые предоставляет другой DApp

### Типы взаимодействий
- Потоковый - позволяет создавать асинхронные pubsub сервисы, для постоянного обмена сообщениями, с возможностью подписки.
- Статичный - позволяет создать еденичный запрос на возвращаемое значение.

### Manifest
*На получение доступа к API другого DApp*
``` js
{
  "activities": [
    "app_name.{service_name}" // Перечисление требуемых activities сервисов
  ]
}
```

### Пояснения к принципам работы
Главная цель нашего взаимодействия в том чтобы наши DApp могли предоставлять и описывать схему относительно сервисов и данных которые они предоставляют, возвращают и тд. Относительно создания удобных обвязок предлагается декларативный стиль для описания схемы данных которую может получать и отправлять наши DApp, в целях безопасности разрешаются для взаимодействия только стандартные типы данных поддерживаемые JSON. С запретом на трансфер бинарных данных, для исключения возможности эксплутации уязвимостей. Также для работы с безопасностью предусматривается что в процессе проверки на запрос данных необходимо подтвердить что установленный DApp который предоставляет сервис - должны быть только от доверенных разработчиков из маркетплейса - чтобы исключить возможность подделки имени бандла и доступа к нему.

#### Дополнительные Возможности относительно декларации запрашиваемых сервисов
Прокси-декларации доступных сервисов, позволит нам генерировать из деклараций запрашиваемых в DApp - полноценные модули API доступные к JS, для целей безопасности будет исключена возможность прямой отправки каких либо сообщений к другому DApp.

``` js
// Плохая реализация
Service.send("other_dapp.service_name", { props: 1, props: 2}) 
```  

``` js
// Хорошая реализация на мета-декларациях
import SomeService from "array.io/services/other_dapp/service_name"

let result = await SomeService(1, 2)
// { ... result }
```

Пояснение: при использовании единого сервиса в который мы отправляем данные, у нас возникает проблема дополнительной валидации в моменте работы с middleware основного процесса который будет оркестрировать данные. Хороший пример подразумевает что у нас есть изолированный компонент, который генерирует нам фантомную сущность через которую проходит рантайм валидацию параметров, входных данных, и данных которые будут возвращаться еще на этапе генерации константной сущности. Также это позволит нам иметь дополнительные гарантии и документирование относительно типизации:

*Относитеьно реальный пример*

Манифест
``` js
[
  "WatchCats",
  "getCats"
]
```

Примерная имплементация сервиса в предоставляющем его DApp
``` js
const { Activity, Static, Service } = GlobalContext

interface Cat {
  name: string,
  age: number
}

@Static
function getCats(userId: string, alive: boolean): Promise<Cat[]> {
  let cats: Cat[] = await query({ userId, alive })
  return cats
}


@Service
class WatchCats implements Broadcast {
  static responseScheme = {
    "alive": "boolean",
    "name": "string"
  };

  onReceive(receiver: Receiver, userId: string, alive: boolean): void {
    // ...
  }

  sendSubscribedCats(receiver: Receiver): void {
    this.send(receiver, { messageByScheme })
  }
}
```

Типизированная декларация
``` typescript 
declare function getCats(user_id: string, alive: bool): Promise<{ name: string, age: number}[]>;
declare function watchCats(user_id: string, alive: bool, cb: ({ name: string, age: number}) => void);
```

Как будет выглядеть вызов сервиса из JS
``` js
import watchCats from "array.io/services/crypto_kitties/watch_cats"
import getCats from "array.io/services/crypto_kitties/get_cats"

// Статичный вызов
let userCats = await getCats("12345", 10) // Возвращаемые значения асинхронные, поэтому они Promise 

// Вызов подписки в сервис
watchCats.subscribe({
  userId: "12345",
  alive: true
}, (cats) => {
  console.log(cats)
})
```

*Пояснение*: В данном примере декларация сервиса производится за счет аннотации, с использованием декоратора функции. Унификация за счет использования декораторов позволяет нам обозначить область использования парсера структуры, и аргументов. Благодаря этому мы может составить базовую схему для создания функций прокси для генерации вызывающих функций из другого DAPP.

Lifecycle Структура.
- Автор DApp который пишет свой сервис оборачивает его в декоратор аннотацию
- Декоратор в контексте связан с экземпляром Activity, и автоматически ассоциирует сервис с каналом сообщений
- В момент компиляции DApp запускается AST парсер вхождений где используются аннотации, по аннотациям выявляется AST сигнатура сервиса и его имплементации
- Из схемы мы забираем все аргументы и их типы, и создаем схематичный генератор относительно сервисов этого DApp
- Другой DApp который захочет использовать сервис, при импорте забирает анализаторы сервисов которые он хочет использовать, и происходит автоматическая мета связка к сервису, создавая функции и методы для запросов.

### Дополнительные ссылки
Похожая мобильная имплементация в системе Android
[IntentService](https://developer.android.com/reference/android/app/IntentService)
[Activity](https://developer.android.com/reference/android/app/Activity)
[Services](https://developer.android.com/guide/components/services)

Средства метапрограммирования фантомных сущностей в js
[Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)
[Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

Написание лоадера относительно webpack сборщика
[Write Webpack Loader](https://webpack.js.org/contribute/writing-a-loader/)